---
title: '뽀모닭 개발기 4편 - 서버 구상 및 설계에 대한 백엔드 이야기(1)'
description: 미정
slug: pomodak-dev-story-4
date: 2024-04-07
excerpt: 하나의 서비스에 Spring과 Nest 두개의 서버를 운영하면서 겪은 문제점과 해결방법
tags:
  - 🐥Pomodak
  - Project
published: true
---

요새 `플러터`를 하느라 백엔드편 작성이 늦어졌습니다. 2주만에 `dart`부터 배우기 시작해서 어느덧 마이그레이션이 끝나가고 있네요...

이틈에 뽀모닭의 백엔드를 언능 정리해보겠습니다.

현재 뽀모닭의 서버는 `Spring`과 `Nest` 두개의 서버로 구성되어 있고, 각기 다른 `ec2`에 배포되어 있습니다.

또한 완전히 분리된 서비스가 아니라서 역할을 분리했다고 해도 서로 의존성이 있습니다. 이번 글에서는 `Nest`나 `Spring` 중점이 아닌 뽀모닭의 `백엔드 구조`에 대한 이야기를 해보려고 합니다.

모바일앱을 만들면서 들었던 생각인데 최고의 앱은 유지보수 비용을 최대한 덜 들면서 아이디어를 최대한 빨리 검증할 수 있는 앱이라고 생각했습니다.

학습의 이유로 `Spring` + `Nest` 조합을 선택했지만, 역시 `서버리스`로 가는게 관리적인 측면에서 훨~~씬 편하고 스트레스도 덜 받는다고 생각이 듭니다.

지금도 `플러터`로 마이그레이션 하면서 타이머 기능을 최대한 로컬로 빼고 `클라우드 백업 & 가져오기`를 통해 멤버의 타이머 기록을 옮기는 등 관리비를 최대한 줄이려고 노력하고 있습니다.

`Nest`로 구현된 서버를 `Spring`으로 전부 마이그레이션 시켜서 `Flutter` + `Spring`만 관리하면 좋을 거 같네요.

## 첫 원대한 꿈

![alt text](https://d2quahb2ygxiv.cloudfront.net/dfa25837c52b83116c601.png?width=800&height=500)

1편에서 소개했던 `팀페이지에서 확장` 시킨게 뽀모닭의 시작이었습니다.

첫 `원대한 꿈`은 팀페이지에 다양한 프로젝트를 심어 하나의 페이지를 통해 프로젝트들을 관리하는 것이었습니다.

그래서 첫 구성은 `팀페이지 API` 서버에 인증시스템을 구현하고, 스터디를 하며 제작한 프로젝트를 하나의 계정과 페이지를 통해 사용할 수 있도록 구현하였습니다.

백엔드로 모인 4명 이었기 때문에 각자 `재미있는 API서버`를 배포하면 팀페이지에 연동시켜 꾸며나갈 계획이 있었습니다.

예를 들어 `날씨 API`를 사용한 서버를 통해 팀페이지의 테마를 추천하여 팀페이지를 날씨에 맞게 변경하거나, 각자의 블로그 글을 크롤링하는 서버를 통해 하나의 탭에서 보여주는 등 다양하게 뻗어나갈 계획이었습니다.

그래서 처음에는 아래와 같이 앱들이 구성되었습니다.

![alt text](https://d2quahb2ygxiv.cloudfront.net/6c60130714892836f7d6a.png?width=800&height=500)

`MongoDB`에 `Account`를 저장하고, 각 API서버에서 멤버가 필요하다면 멤버 모델을 만들어서 해당 서버가 사용중인 인프라에 `AccountId`를 함께 저장하는 방식으로 구현되었습니다.

`OAuth` 방식처럼 인가코드를 발급해서 각 서버에서 인증 서버에 한번더 검증할까 했지만 크게 보안이 중요한 프로젝트도 아니고, 간소화를 위해 그냥 JWT 토큰에 `AccountId`를 넣어서 `시크릿키`만 통일하여 사용하였습니다.

또한 `토큰 만료 에러`가 발생하면 `인증서버`에서 `리프레시 토큰`을 통해 재발급해주는 방식으로 구현하였습니다.

다행히 이렇게 구현한 서버 구조는 예상대로 잘 동작하였고, 팀페이지에 다양한 서버를 연동시킬 수 있었습니다.

## 현실적인 문제

![alt text](https://d2quahb2ygxiv.cloudfront.net/2b83116c6013071489283.png?width=800&height=500)

<ImageCaption text="하루빨리 이미지 확대기능을 추가하겠습니다..." />

처음에는 위 구조에서 `Nest`가 배포된 ec2에 `Nest` 인증서버가 추가로 docker를 통해 실행되어, 외부 `Atlas MongoDB`를 통해 `Account`를 관리하고 있었습니다.

하지만 아래와 같은 문제로 인해 구조를 `Nest`서버를 하나로 통합하는 방식으로 변경하게 되었습니다.

### 자원 & 복잡성 문제

기존에 가혹한 `ec2 프리티어`에서 `docker compose`로 `Nest`서버 2개, `nginx`, `certbot` 까지 4개의 이미지를 배포하니 프리티어의 메모리를 뚫고 `스왑 메모리`까지 어느정도 사용하고 있었습니다.

또한 `Account`가 외부 `MongoDB`에 저장되어 있고 관리 또한 뽀모닭이 아닌 외부 서버와 DB에서 관리되기 때문에 복잡도와 피로도가 높았습니다.

따라서 개선이 필요했고, 기존에 모노레포로 구성되어 있던 두개의 `Nest`서버에서 `팀페이지 서버를 제거`하고, Account를 MySQL에 마이그레이션 하여 `Nest`를 하나의 서버로 통합하였습니다.

이렇게 구성하니 서버의 `스왑 메모리`도 사용하지 않고 `120Mi` 정도 `여유 메모리`가 확보되었고, 현재는 위 같이 백엔드가 구성되었습니다.

### 정책 문제?

`뭔가` 정책에 대한 문제가 있을 것 같다는 생각이 들었습니다.

`고지되지 않은 다른 서비스`(팀페이지)에도 가입되며 파생된 여러 앱들이 이용 가능하면 `뭔가`가 귀찮아질 것 같았습니다. (`개인정보처리방침`, `서비스 이용약관` 등)

그래서 위 인증서버를 병합하면서 기존에 시간과 자원 문제로 관리가 어렵던 `팀페이지 서버를 제거`하고, `뽀모닭에 집중 투자`를 하기로 결정하였습니다.

따라서 하나의 인증서버에서 여러 서비스를 사용하던 방식에서, 뽀모닭 서버에 인증로직을 옮기게 되었고 현재는 `Spring`과 `Nest`로 구성된 `뽀모닭 서버만 운영`하고 있습니다.

## `Spring`과 `Nest` 협업 시 고려할 점

사실 `Spring`과 `Nest`는 구조도 엇비슷하고, 어차피 `http api 서버`가 거기서 거기라 협업이 크게 어렵지 않다고 생각했었습니다.

하지만 각 언어가 지향하는 방식이 다르고, `공유 자원`을 사용할 때는 특별히 주의가 더 필요합니다.

### 1. 공유 자원의 동기화 및 캐시 문제

`Spring`과 `Nest`는 `MySQL`을 공유하고 있습니다. 그래서 `MySQL`에 데이터를 쓰고 읽는 작업이 동시에 일어날 수 있습니다.

저희는 최대한 `동시성 문제`를 피하기 위해 하나의 자원에 대해 `읽기/쓰기 작업을 분리`하고 있습니다.

예를 들어, `Nest`에서는 타이머 기록에 대한 `CRUD`를 진행한다면 `Spring`에서는 타이머 기록에 대해서는 읽기만 진행할 수 있습니다.

이렇게 분리하면 `동시성 문제`를 피할 수 있지만, `캐시 문제`가 발생할 수 있습니다.

예를 들어 `Nest`에서 멤버 데이터 조회를 처리하고 캐싱을 해뒀는데 `Spring`에서 데이터를 수정했을때(아이템 사용으로 인한 포인트 획득 등) 캐시를 갱신해야 하기 때문에 `캐시 무효화 API`를 만들어야 할 수도 있습니다.

`캐시 문제`는 어떤 서버에서든 발생할 수 있는 문제이지만, 서버가 두개인 경우에는 더욱 신경써야 할 문제라고 생각합니다.

저희도 `Spring`서버를 `Nest` 뒤에 두고 엔드포인트를 통합하여 캐시를 처리할까 생각했지만

데이터 특성상 조회하는 데이터가 게시글 같은 공유 데이터가 아니라서 서버는 항상 최신 데이터를 가져오도록 하고, 아래와 같이 `프론트에서 비즈니스 로직에 의한 캐싱 처리`를 수행했습니다.

![alt text](https://d2quahb2ygxiv.cloudfront.net/c60130714892836f7d6a1.png?width=800&height=500)

하지만 유저 수정은 `Nest`에 구현되어 있지만 `Spring`에서도 point를 추가하는 등 유저 데이터를 수정하는 예외도 존재합니다.

하지만 `멤버 정보 수정 API`와 `아이템 사용 API`는 실제 유저가 동시에 요청할 수 `없는` 작업이기 때문에 `동시성 문제`는 발생하지 않을 것 같습니다.

이처럼 `CRUD 작업`을 양쪽에서 진행해야 하는경우 신중하게 고려해야 할 것 같습니다.

저희 경우는 아니지만 만약 앱이 하나의 자원을 여러 유저가 사용하고 수정할 수 있는 기능이 존재한다면 `트랜잭션 lock`을 통한 `동기화 처리`도 필요하게 됩니다.

### 2. `Spring` 예약어 문제

`Nest`를 할땐 몰랐는데 `User`라는 스키마를 만들었더니 `Spring`에서 `User`라는 이름이 시큐리티에서 이미 사용중이라 컴파일 에러가 발생했습니다.

`User` 외에도 `Role`, `Transaction`, `Group` 등의 예약어가 있으니 고려해야 할 것 같습니다.

물론 `어노테이션`을 통해 이름을 변경할 수 있지만, 그냥 피하는게 좋을 것 같습니다.

### 3. ORM 차이로 인한 동작 차이 & 마이그레이션 문제

`Spring`과 `Nest`는 각기 다른 ORM을 사용하고 있습니다. `Spring`은 JPA를 사용하고, `Nest`는 TypeORM을 사용합니다.

동일하게 스키마를 만들어도 실제 데이터베이스에 저장되는 형태가 다르기 때문에 `마이그레이션` 시에 문제가 발생할 수 있습니다.

예시로 `Java`는 독립적인 생태계에서 `JPA`가 다양한 `외부 DB`를 연동하기 위해서 `RDBMS`에서 `필수적인 기능만 DDL로 지원`하고, 나머지는 `JPA`에서 처리 구현하는 방식을 지향합니다.

하지만 `Node`는 `TypeORM`이라는 `ORM`을 사용하는데, `MySQL`을 사용하려면 `MySQL` 모듈로 연동하고, `PostgreSQL`을 사용하려면 `PostgreSQL` 모듈로 연동해야 합니다.

따라서 `Node`에서 스키마를 만들어서 `DB`에 적용하면 `cascade` 나 `constraint` 같은 설정이 모두 `실제 DB`에 반영하는 반면 `Spring`은 `JPA`가 이를 처리해주기 때문에 `실제 DB`에 반영되지 않는 문제가 있습니다.

실제로 `Java`에서 작성한 스키마를 적용시키고 `Node`에서 동일하게 스키마를 작성하고 데이터를 생성하면 아래와 같은 상황이 발생합니다.

![alt text](https://d2quahb2ygxiv.cloudfront.net/60130714892836f7d6a17.png?width=800&height=500)

위 문제를 피하기 위해 `Node`에서 스키마를 만들어서 `DB`에 반영하고, `Spring`에서는 스키마를 `DB`에 반영하지 않는 방식으로 운영하고 있습니다.

또한 양측 모두 auto_ddl을 사용하지 않고 `Node`에서 migration generator를 사용하여 마이그레이션을 진행하고 있습니다.

### 4. 날짜 문제

3번의 `JPA`와 `TypeORM`의 차이로 인해 발생하는 문제 중 하나가 날짜 문제입니다.

`TypeORM`은 기본적으로 `DB에서 날짜가 생성`되기를 기대하고 있습니다. 그래서 `Node`에서 날짜를 생성하지 않으면 자동으로 `DB`에서 생성되는 방식입니다.

하지만 `JPA`는 `JPA`에서 `날짜를 생성하고 DB에 넣는 방식`이기 때문에 `Java`는 서버시간, `Node`는 DB시간을 기준으로 날짜를 생성하게 됩니다.

따라서 서버의 시간대가 다를 수 있으니 서버에서 날짜를 생성하지 않고 DB시간을 기준으로 날짜를 생성하도록 하는게 좋을 것 같습니다.

### 5. e2e 테스트 문제

`Nest`에 로그인이 구현되어 있기 때문에 `Spring`에서 e2e 테스트를 진행할 때 `Nest`를 통한 로그인이 필요합니다.

이를 위해 `localhost`에서 서버를 띄우고 테스트를 진행한다고 해도 `Nest` 서버도 함께 띄우거나 `테스트 서버`를 배포해야 하는 문제가 있습니다.

하지만 뽀모닭을 `production`로 배포하면서 남는 `프리티어`가 없기 때문에 임시로 `jwt 토큰`을 직접 받아와 `환경변수`로 넣어주는 방식으로 테스트를 진행하고 있습니다.

물론 충분한 자원이 있고, `테스트 서버`를 띄울 수 있다면 이런 문제는 없을 것 같습니다.

## 마치며

사실 `Spring`과 `Nest`의 협업은 `Java`와 `Node`의 개발 문화, 생태계, ORM의 차이로 인해 발생하는 문제가 있지만, 그런 문제들을 해결하면 그냥 두개의 웹서버를 운영하는 것과 크게 다르지 않습니다.

학습 목적으로 `스프링`과 `네스트`를 협업시켜보았지만, 이틀 뒤면 출시가 되는데 운영하려고 하니 머리가 아프네요.

그래도 뽀모닭을 만들면서 두개의 서버를 구성하고 협업하면서 배운 것들이 많아서 좋았습니다.

그리고 `flutter`로 전환하면서 `local notification`으로 예약 푸시알림을 날릴 수 있어 `Nest`에 구현된 상당한 부분을 로컬로 옮길 수 있었습니다.

또한 `클라우드 백업 & 가져오기`를 통해 멤버의 타이머 기록을 옮기는 등 `관리비를 최대한 줄이려고` 노력하고 있습니다.

결론은 관리비가 적게 드는 앱이 최고다!
