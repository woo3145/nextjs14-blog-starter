---
title: '뽀모닭 개발기 8편 - 플러터가 망한다고? Flutter 전환기 (2)'
description: 라우팅 및 타이머 구현
date: '2024-05-03'
image: 'https://d2quahb2ygxiv.cloudfront.net/f543bea9849fb3a9d6b6b.png'
authors:
  - woo3145
tags:
  - 🐥Pomodak
  - Project
  - Flutter
  - Mobile
published: false
---

최근 플러터 팀이 대규모 해고를 당해서 플러터가 버려진다는 소문이 돌고있습니다.

이에따라 프로덕트 매니저 [Michael Thomsen이 아래와 같은 트윗](https://twitter.com/walkingriver/status/1786041534455980225)을 남겼습니다.

![image](https://d2quahb2ygxiv.cloudfront.net/543bea9849fb3a9d6b6b2.png)

몇시간전 댓글에서 플러터 개발자를 채용할 예정이라고 밝힌 것을 보면 플러터가 버려진다는 소문은 사실이 아닌 것 같습니다.

그저 구글의 전체적인 구조조정중 플러터팀도 그에 따른 구조조정이 있던 것 같습니다.

그래도 프로그래밍 언어나 프레임워크는 언제든지 사라질 수도 있고, 새로운 기술이 나오기도 하니 그저 현재의 기술을 잘 활용하고 빠르게 적응하는 것이 중요한 것 같습니다.

그럼 이제 본격적으로 뽀모닭 이야기를 시작해보겠습니다.

## 라우팅 구현

플러터에서 라우팅은 `Navigator 위젯`에서 관리합니다. 스택 구조로 되어있어서 `push`, `pop`을 통해 화면을 전환할 수 있습니다.

보통 `Widget.of(context)`는 상위에서 가장 가까운 위젯을 찾아주는 역할을 하는데 이를 이용해 가장 가까운 Navigator를 찾아 라우팅을 수행할 수 있습니다.

- `Navigator.of(context).push('/route')` or `Navigator.push(context, '/route')`
- `Navigator.of(context).pop()` or `Navigator.pop(context)`

- 추가로 `Navigator.of(context, rootNavigator: true)`를 사용하면 최상단의 Navigator를 찾을 수 있습니다.

### go_router 패키지 사용

제가 원하는 라우팅 동작은 다음과 같습니다.

- `splash 화면`에서 필수 초기 데이터 로딩
- 라우터가 `viewModel`을 통해 로그인 여부를 감지하고 이에 따라 화면 전환
- 상태에 따라 리다이렉트(초기화가 안되었을때 다른 라우터 접근, 로그인된 상태에서 로그인 페이지 접근 등)

Navigator를 사용하면 많이 복잡해지기 때문에 이를 좀더 간편하게 관리하기 위해 `go_router` 라이브러리를 사용하였습니다.

`go_router`는 기존 Navigator와 달리 URL 기반의 라우팅을 지원하는 패키지입니다.

제일 자주 사용되는 메서드는 다음 3가지 입니다.

- `context.go('/route')` : 해당 경로로 이동
- `context.push('/route')` : 해당 경로로 이동하고 이전 경로를 스택에 저장
- `context.pop()` : 이전 경로로 이동

[go_router의 문서](https://pub.dev/documentation/go_router/latest/go_router/go_router-library.html)에서 여러 메서드 사용법을 찾기 굉장히 어렵기 떄문에 `Command + 클릭`을 통해 필요한 메서드를 찾는 것을 추천합니다.

### provider와 go_router를 통한 라우팅 구현

라우팅을 위한 `AppRouter` 클래스의 전체적인 구조는 다음과 같습니다.

```dart
GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

class AppRouter {
  final AppViewModel appViewModel;
  final AuthViewModel authViewModel;
  late final GoRouter _goRouter;

  AppRouter({required this.appViewModel, required this.authViewModel}) {
    _goRouter = _initGoRouter();
  }

  GoRouter get router => _goRouter;

  GoRouter _initGoRouter() {
    return GoRouter(
      refreshListenable: Listenable.merge([appViewModel, authViewModel]),
      initialLocation: AppPage.splash.toPath,
      routes: _getRoutes(),
      errorBuilder: (context, state) =>
          ErrorPage(error: state.error.toString()),
      redirect: _redirectLogic,
      navigatorKey: navigatorKey,
    );
  }

  List<GoRoute> _getRoutes() {
    return [
      GoRoute(
        path: AppPage.home.toPath,
        name: AppPage.home.toName,
        builder: (context, state) => const MyHomePage(),
      ),
      GoRoute(
        path: AppPage.splash.toPath,
        name: AppPage.splash.toName,
        builder: (context, state) => const SplashPage(),
      ),
        // ...
    ];
  }

  String? _redirectLogic(BuildContext context, GoRouterState state) {
    final isLoggedIn = authViewModel.isLoggedIn;
    final isInitialized = appViewModel.initialized;

    final locations = {
        // ...
      'login': state.namedLocation(AppPage.login.toName),
      'home': state.namedLocation(AppPage.home.toName),
      'splash': state.namedLocation(AppPage.splash.toName),
    };

    if (!isInitialized && state.matchedLocation != locations['splash']) {
      return locations['splash'];
    }

    if ((isLoggedIn &&
            (state.matchedLocation == locations['login'] ||
                state.matchedLocation == locations['welcome'] ||
                state.matchedLocation == locations['register'])) ||
        (isInitialized && state.matchedLocation == locations['splash'])) {
      return locations['home'];
    }
    // ...

    return null;
  }
}

```

#### viewModel을 통한 상태 감지

먼저 라우터가 감지해야할 상태는 다음과 같습니다.

- `appViewModel` : 앱의 초기화 여부
- `authViewModel` : 로그인 여부(jwt 토큰이 존재하는지)

goRouter에선 `refreshListenable`을 통해 리스너를 등록할 수 있고 merge를 통해 여러개의 리스너를 등록할 수도 있습니다.

```dart
// app_router.dart

AppRouter({required this.appViewModel, required this.authViewModel}) {
    _goRouter = _initGoRouter();
}

GoRouter _initGoRouter() {
    return GoRouter(
        refreshListenable: Listenable.merge([appViewModel, authViewModel]),
        // ...
    );
}

// main.dart
final appRouter = AppRouter(
    appViewModel: getIt<AppViewModel>(),
    authViewModel: getIt<AuthViewModel>());
final goRouter = appRouter.router;

MaterialApp.router(
    // ...
    routerConfig: goRouter,
)
```

#### redirect 처리

이제 provider를 통해 상태를 감지할 수 있게 되었으니 이를 통해 리다이렉트 로직을 구현할 수 있습니다.

`locations`에서 이동하려는 페이지의 경로를 미리 저장해두고, `state.matchedLocation`을 통해 현재 위치와 비교하여 해당 페이지로 이동하는지 확인할 수 있습니다.

초기화 & 로그인 여부와 결합하여 적절한 리다이렉트를 통해 접근을 제어할 수 있습니다.

```dart
// app_router.dart

String? _redirectLogic(BuildContext context, GoRouterState state) {
    final isLoggedIn = authViewModel.isLoggedIn;
    final isInitialized = appViewModel.initialized;

    final locations = {
        // ...
      'login': state.namedLocation(AppPage.login.toName),
      'home': state.namedLocation(AppPage.home.toName),
      'splash': state.namedLocation(AppPage.splash.toName),
    };

    // 초기화가 되지 않았을때 무조건 splash 페이지로 이동
    if (!isInitialized) {
      return locations['splash'];
    }

    // 로그인이 되어있는데 로그인 관련 페이지로 접근하거나 초기화가 이미 완료되었는데 splash 페이지로 접근하면 home 페이지로 이동
    if ((isLoggedIn &&
            (state.matchedLocation == locations['login'] ||
                state.matchedLocation == locations['welcome'] ||
                state.matchedLocation == locations['register'])) ||
        (isInitialized && state.matchedLocation == locations['splash'])) {
      return locations['home'];
    }
    // ... 다양한 상황 처리

    return null;
}
```
