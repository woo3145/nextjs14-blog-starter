---
title: '뽀모닭 개발기 7편 - React+ PWA에서 Flutter 전환기 (1)'
description: 한달만에 Dart 학습부터 Flutter로 네이티브앱 배포까지 끝내기
date: '2024-04-28'
image: 'https://d2quahb2ygxiv.cloudfront.net/d3326ef543bea9849fb3a.png'
authors:
  - woo3145
tags:
  - 🐥Pomodak
  - Project
  - Flutter
  - Mobile
published: true
---

뽀모닭을 플러터로 마이그레이션하면서 겪은 과정을 공유합니다.

일주일정도 일때문에 작업을 거의 못해서 실제 작업은 3주 정도 걸린 것 같습니다.

리액트 네이티브와 플러터 중 엄청 고민했는데, 플러터를 선택한게 정말 만족스러웠습니다.

PWA를 배포하면서 생성한 안드로이드 인증서(signing.keystore)를 생성했었는데, 이미 해당 인증서로 서명된 앱을 배포했기 때문에 플러터로 마이그레이션하면서 해당 인증서를 사용하여 버전업을 진행했습니다.

아무래도 네이티브 앱 개발이 처음이라 iOS와 안드로이드의 환경과 빌드 과정 등에 시간을 좀더 투자한 것 같습니다.

크로스 플랫폼 앱개발을 고려할때 리액트 경험 때문에 리액트 네이티브로 결정하기 보다 플러터도 한번 고려할 만한 가치가 있다고 생각합니다.

iOS는 앱스토어 개발자 계정등록이 상당히 오래걸리네요. 최대 3주까지 걸린다고 해서 iOS는 이후에 배포를 진행해야 할 것 같습니다.

## 작업 기간

3월 24일 시작 ~ 4월 24일 배포 완료

dart 학습부터 구글 플레이 스토어 배포까지 딱 한달이 걸렸네요.

작업은 대략적으로 다음과 같이 진행했습니다.

- 1일차 - dart언어 학습 & 플러터 프로젝트 생성

- 2 ~ 3일차 - 오직 UI 작업만 진행하면서 dart와 flutter에 익숙해지기

- 4일차 - 상태관리 방식 조사 & Provider로 상태관리 적용

- 5일차 - API 처리방식 조사 (http 패키지 적용) & 로컬 저장소 조사 (shared_preferences, secure_storage 적용)

- 6일차 - 라우팅 처리 조사 & go_router 적용

- 7 ~ 14일차 - 타이머 관련 기능, UI 작업 & API 사용 기능 작업

- ~~15 ~ 21일차 - 무대음향 업무로 인해 거의 작업 중단~~

- 22 ~ 23일차 - socket 기능 작업

- 24 ~ 30일차 - 리팩토링 및 안드로이드, iOS 빌드 체크

- 31일차 - 구글 플레이스토어 배포

## Dart 첫 만남

dart는 각 언어의 특징이 잘 섞인 언어라고 생각이 들었습니다.

타입스크립트가 애초에 기존 자바스크립트에 타입과 객체지향적인 특징을 확장하고 다양한 프로그래밍 언어의 장점을 가져온다는 특징이 있어서 dart도 굉장히 익숙한 느낌이 들었습니다.

또한 dart와 javascript 두 언어 모두 단일 스레드 기반이라 이벤트 루프를 통해 비동기 처리를 하기 때문에 dart도 쉽게 접근할 수 있을 것 같습니다.

개인적으로 언어 학습은 실제로 사용하면서 익히는게 빠르기 때문에 공식문서를 한번 훑고 간단한 UI 작업을 통해 익숙해지는 것이 가장 효율적이라고 생각합니다.

그래서 실질적인 dart 학습은 몇시간 정도 문서를 읽으면서 전체적인 틀을 파악하고, 실제 작업을 통해 문서를 참고하면서 익혔습니다.

dart 공식문서에 코딩 컨벤션이 굉장히 잘 정리되어 있고 vscode 내에서 잘못된 네이밍에 대한 경고도 잘 나오는 점도 장점이라고 생각합니다.

## Flutter 첫 만남

플러터 또한 공식 문서가 굉장히 잘 정리되어 있습니다. UI 이외에도 상태관리, 직렬화, 네트워킹 등등 다양한 주제와 패키지들이 잘 정리되어 있어서 실제 작업을 하면서 문서를 참고하는 것이 굉장히 편했습니다.

하지만 모바일 개발이라 xcode와 android studio도 같이 사용해야 하고, 모바일 시뮬레이터가 상당히 무겁다는 단점이 있습니다.

개발 자체는 lib 폴더 내에서 대부분 작업을 하지만 패키지 추가시 iOS와 안드로이드 설정 파일등을 수정해야하고, 종종 xcode와 android studio를 열어서 작업을 해야하는 점이 까다로웠습니다.

또한 iOS와 안드로이드 빌드 과정을 공부해야하고 사용자의 기기에 직접 설치하기 때문에 인증서 및 프로비저닝 파일과 같은 보안 설정에 대해서도 공부해야하는 점이 있습니다.

그래도 왠만한 UI가 widget으로 구성되어 있어서 UI 작업은 굉장히 빠르게 진행할 수 있었습니다. 레고 블럭을 쌓듯이 UI를 구성할 수 있어서 리액트의 잘 만들어진 UI 라이브러리를 사용하는 것과 비슷한 느낌이었습니다.

하지만 개발자풀이 js에 비해 많이 적기 때문에 package가 많이 부족해서 직접 구현해야하는 경우도 존재하고, 패키지 도입시 버그가 존재하는지, 해결법은 있는지 충분히 조사를 해야하는 점이 있습니다.

결론적으로 플러터는 굉장히 만족스러웠습니다. 기존 PWA와 비교했을때 웹브라우저의 제약사항이 없어서 서버 없이 처리할 수 있는 부분도 많았고, 사용자 경험 및 성능면에서도 만족스러웠습니다.

## UI 작업

UI 작업은 기존 PWA에서 불편했던 부분을 개선하면서 진행했습니다.

초기에는 실제 기능을 statefull widget으로 간단한 상태를 통해 모킹하면서 UI를 구성하면서 플러터에 익숙해지고 BuildContext와 위젯 트리에 대해 이해하는데 중점을 두었습니다.

또한 UI를 구성하면서 자주 사용하는 위젯들에 익숙해지고 공식 문서의 위젯 카탈로그를 참고하면서 UI를 구성했습니다.

또한 캘린더나 잔디 그래프와 같은 경우 직접 구현하면 시간이 많이 걸리기 때문에 pub.dev에서 아래 두개의 패키지를 찾았습니다.

- [table_calendar](https://pub.dev/packages/table_calendar)
- [flutter_heatmap_calendar](https://pub.dev/packages/flutter_heatmap_calendar)

하지만 아래의 flutter_heatmap_calendar는 세로모드를 지원하지 않고 issue를 보니 작년 review도 확인이 안되어있어서 소스를 참고하여 구현했습니다.

flutter_vertical_heatmap로 다듬고 정리해서 pub.dev에 배포해보고 싶었는데 이때 당시에는 해야할 작업이 많아서 일단 미뤄두었습니다.

작업물은 아래와 같습니다. 뽀모닭 디자인에 맞춘 위젯이라 좀더 다듬어서 배포를 해야할 것 같네요.

![alt text](https://d2quahb2ygxiv.cloudfront.net/ef543bea9849fb3a9d6b6.png?width=500)

## 상태관리

Flutter의 공식문서에서 Beyound UI/State management가 굉장히 잘 정리되어 있습니다.

StatefulWidget부터 Provider, Bloc, Riverpod, Mobx, Redux, GetX 등 다양한 상태관리 방식이 있지만, 제가 선택한 것은 Provider였습니다.

Bloc과 Provider중 고민을 많이 했는데, 작업 인원도 1명이고, 엄청나게 복잡한 상태관리가 필요하지 않다고 판단하여 상대적으로 학습곡선이 적은 Provider로 선택했습니다.

### Get_it

기존에는 아래와 같이 DI를 직접 구현했습니다.

하지만 연관된 데이터 그룹을 생성할때마다 레포지토리, 데이터소스, 서비스 등을 생성해야하고 뷰모델간 의존성 주입이 생기면 코드가 복잡해지고 관계를 파악하기 점점 어려워져서 Get_it을 적용했습니다.

#### 기존

```dart
class _MyAppState extends State<MyApp> {
  // ...
  @ovveride
  void initState() {
    super.initState();

    // 로컬 저장소
    authStorage = AuthStorage();
    final SharedPreferences sharedPreferences =
      await SharedPreferences.getInstance();

    // dio 인스턴스 (http 통신 & auto refresh token)
    apiService = NetworkApiService(storage: authStorage);

    // 데이터 소스
    memberLocalDatasource = MemberLocalDatasource(storage: sharedPreferences);
    memberRemoteDatasource = MemberRemoteDataSource(apiService: apiService);

    // 레포지토리 (로컬/api간 캐싱 & 데이터 처리)
    memberRepository = MemberRepository(remoteDatasource: memberRemoteStorage, localDatasource: memberLocalDatasource);

    // ... 생략

    // 뷰모델
    inventoryViewModel = InventoryViewModel(repository: inventoryRepository);
    memberViewModel = MemberViewModel(repository: memberRepository, inventoryViewModel: inventoryViewModel);

  }
}
```

#### Get_it 적용

Get_it을 통해 의존성 파일을 분리하고, Get_it을 통해 의존성을 주입하도록 변경했습니다.

```dart
final getIt = GetIt.instance;

Future<void> setupLocator() async {
  // local 저장소 (Hive, SharedPreferences, FlutterSecureStorage 등)
  await registerLocalStoragies();

  // (local)DataSource (local 저장소를 주입받아 데이터를 처리)
  registerLocalDataSource();
  // NetworkApiService (외부 서버와 통신 - authLocalDataSource가 필요하기 때문에 localDataSource를 먼저 등록)
  getIt.registerLazySingleton<NetworkApiService>(() =>
      NetworkApiService(authLocalDataSource: getIt<AuthLocalDataSource>()));
  // (remote)DataSource (apiServices를 주입받아 외부 서버에서 데이터를 처리)
  registerRemoteDataSource();

  // Repository (dataSources를 이용하여 데이터를 처리)
  registerRepository();

  // ViewModel (repositories를 주입받아 view에서 사용할 데이터를 처리)
  registerViewModels();
}

// local 저장소 등록
Future<void> registerLocalStoragies() async {
  // ...
  // SharedPreferences (간단한 설정 같은 key-value 쌍을 저장하는 용도)
  final SharedPreferences sharedPreferences =
      await SharedPreferences.getInstance();
  getIt.registerLazySingleton<SharedPreferences>(() => sharedPreferences);

  // FlutterSecureStorage (보안이 필요한 데이터 (토큰, 계정 정보 등)를 저장하는 용도)
  getIt.registerLazySingleton<FlutterSecureStorage>(
      () => const FlutterSecureStorage());
}

// LocalDataSource
void registerLocalDataSource() {
  // ...
  getIt.registerLazySingleton<MemberLocalDataSource>(
      () => MemberLocalDataSourceImpl(getIt<SharedPreferences>()));
}

// RemoteDataSource
void registerRemoteDataSource() {
  // ...
  getIt.registerLazySingleton<MemberRemoteDataSource>(
      () => MemberRemoteDataSourceImpl(apiService: getIt<NetworkApiService>()));
}

// Repository
void registerRepository() {
  // ...
  getIt.registerLazySingleton<MemberRepository>(
    () => MemberRepository(
      localDataSource: getIt<MemberLocalDataSource>(),
      remoteDataSource: getIt<MemberRemoteDataSource>(),
    ),
  );
}

// View Model
void registerViewModels() {
  // ...
  getIt.registerLazySingleton<MemberViewModel>(
    () => MemberViewModel(repository: getIt<MemberRepository>()),
  );
}
```
